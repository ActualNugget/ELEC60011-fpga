module cordic_cosine (
    input wire [31:0] dataa,      // 32-bit fixed-point input (-1 to 1)
    output reg [31:0] result      // 32-bit fixed-point output (cosine value)
);

    // Constants
    localparam ITERATIONS = 18;    // Number of iterations
    localparam SCALE = 32'h5f47c274; // K value for 18 iterations (1/K)
    localparam PI_OVER_4 = 32'h2d413ccc; // Ï€/4 in 32-bit fixed-point (2 integer bits, 30 fractional bits)

    // Internal registers
    reg signed [31:0] x;          // X register
    reg signed [31:0] y;          // Y register
    reg signed [31:0] z;          // Angle register
    reg signed [31:0] angle[0:ITERATIONS-1]; // Precomputed angles

    // Precompute the angles for CORDIC iterations
    initial begin
        angle[0] = PI_OVER_4;
        for (int i = 1; i < ITERATIONS; i = i + 1) begin
            angle[i] = angle[i-1] >>> 1; // Divide by 2
        end
    end

    // CORDIC algorithm
    always @(*) begin
        x = dataa; // Initialize X with input data
        y = 32'h0; // Initialize Y to 0
        z = 32'h0; // Initialize angle to 0

        for (int i = 0; i < ITERATIONS; i = i + 1) begin
            reg signed [31:0] y_shifted = y >>> i; // Shift Y right by i
            reg signed [31:0] x_new, y_new, z_new;

            if (y >= 0) begin
                x_new = x - y_shifted;
                y_new = y + x_shifted;
                z_new = z - angle[i];
            end else begin
                x_new = x + y_shifted;
                y_new = y - x_shifted;
                z_new = z + angle[i];
            end

            x = x_new;
            y = y_new;
            z = z_new;
        end

        // Scale the result by 1/K
        result = (x * SCALE) >>> 30;
    end

endmodule